# llms.txt: End-User Usage Guide for ccxt_client

Use this guide when assisting end users of `ccxt_client`.

`ccxt_client` is an Elixir package (`:ccxt_client`) that exposes a unified API across 100+ exchanges through modules such as `CCXT.Binance`, `CCXT.Bybit`, and `CCXT.Deribit`.

Important current behavior:
- All data families (Ticker, Trade, OrderBook, Balance, Order, Position, OHLCV, Market) return normalized structs by default.
- Pass `normalize: false` to receive raw exchange payloads instead.

## 1) Installation and Startup
```elixir
# mix.exs
defp deps do
  [
    {:ccxt_client, "~> 0.2"}
  ]
end
```

```bash
mix deps.get
mix compile
iex -S mix
```

## 1.1) Selective Compilation (Exchange Whitelist)
By default, all bundled exchanges are compiled.

To compile only selected exchanges, set:

```elixir
# config/config.exs
config :ccxt_client, exchanges: [:binance, :bybit, :okx]
```

You can pass exchange IDs as atoms or strings. Unlisted exchanges compile as stub modules (no generated API functions), which reduces compile time and binary size.

Quick verification:

```bash
mix compile
iex -S mix
```

```elixir
function_exported?(CCXT.Binance, :fetch_ticker, 1)
```

See `README.md` ("Selective Compilation") for broader generation/scaffolding context.

## 2) Public Market Data (No Credentials)
Use exchange modules directly.

```elixir
{:ok, ticker} = CCXT.Bybit.fetch_ticker("BTC/USDT")
{:ok, book} = CCXT.Bybit.fetch_order_book("BTC/USDT")
{:ok, trades} = CCXT.Deribit.fetch_trades("BTC-PERPETUAL", nil)
```

If an exchange needs custom API fields, pass them via `params:`:

```elixir
CCXT.Bybit.fetch_ticker("BTCUSDT", params: %{category: "spot"})
```

## 3) Private Endpoints (Credentials)
Create credentials once, then reuse.

```elixir
creds = CCXT.Credentials.new!(
  api_key: System.fetch_env!("BYBIT_TESTNET_API_KEY"),
  secret: System.fetch_env!("BYBIT_TESTNET_API_SECRET"),
  sandbox: true
)

{:ok, balance} = CCXT.Bybit.fetch_balance(creds)
```

Deribit testnet commonly uses `DERIBIT_TESTNET_SECRET_KEY`:

```elixir
deribit_creds = CCXT.Credentials.new!(
  api_key: System.fetch_env!("DERIBIT_TESTNET_API_KEY"),
  secret: System.fetch_env!("DERIBIT_TESTNET_SECRET_KEY"),
  sandbox: true
)
```

Some exchanges also require `password`/passphrase:

```elixir
creds = CCXT.Credentials.new!(
  api_key: "...",
  secret: "...",
  password: "...",
  sandbox: true
)
```

## 4) Trading Flow Example
```elixir
{:ok, order} = CCXT.Bybit.create_order(
  creds,
  "BTC/USDT",
  :limit,
  :buy,
  0.001,
  50_000.0
)

{:ok, fetched} = CCXT.Bybit.fetch_order(creds, order.id, "BTC/USDT")
{:ok, _} = CCXT.Bybit.cancel_order(creds, order.id, "BTC/USDT")
```

## 5) Error Handling Pattern
The library uses `{:ok, result}` / `{:error, reason}` tuples. Many exchange errors are normalized to `%CCXT.Error{}`.

```elixir
case CCXT.Bybit.create_order(creds, "BTC/USDT", :limit, :buy, 0.001, 50_000.0) do
  {:ok, order} -> order
  {:error, %CCXT.Error{type: :rate_limited, retry_after: ms}} -> Process.sleep(ms)
  {:error, %CCXT.Error{type: :invalid_credentials}} -> :fix_keys
  {:error, reason} -> {:unexpected_error, reason}
end
```

## 6) Discover Exchange Capabilities
Use introspection helpers before calling advanced endpoints:

```elixir
CCXT.Bybit.__ccxt_endpoints__()
CCXT.Bybit.__ccxt_spec__()
CCXT.Bybit.__ccxt_signing__()
CCXT.Bybit.__ccxt_classification__()
CCXT.Bybit.__ccxt_precision_mode__()
```

WebSocket introspection:

```elixir
CCXT.Bybit.WS.__ccxt_ws_spec__()
CCXT.Bybit.WS.__ccxt_ws_pattern__()
CCXT.Bybit.WS.__ccxt_ws_channels__()
```

## 7) REST Cookbook (Common Tasks)
Assume `ex = CCXT.Bybit` and `creds` is already created.

```elixir
# 1) Get one ticker
{:ok, ticker} = ex.fetch_ticker("BTC/USDT")

# 2) Get many tickers (current safe shape in this build)
{:ok, tickers} = ex.fetch_tickers(nil)

# 3) Get order book
{:ok, order_book} = ex.fetch_order_book("BTC/USDT")

# 4) Get recent public trades
{:ok, trades} = ex.fetch_trades("BTC/USDT")

# 5) Get OHLCV candles (normalized %OHLCVBar{} structs)
{:ok, bars} = ex.fetch_ohlcv("BTC/USDT", "1m")

# 6) List markets supported by an exchange
{:ok, markets} = ex.fetch_markets()

# 7) Get account balance (private)
{:ok, balance} = ex.fetch_balance(creds)

# 8) List open orders (private)
{:ok, open_orders} = ex.fetch_open_orders(creds, "BTC/USDT")
```

If a call fails, first verify symbol format and check supported endpoints:

```elixir
ex.__ccxt_endpoints__()
```

## 8) Market Precision Metadata
`fetch_markets` returns `[%CCXT.Types.MarketInterface{}]` by default. Each struct includes `precision` and `limits` maps.

Use `CCXT.MarketPrecision` to normalize precision data across exchanges:

```elixir
alias CCXT.MarketPrecision

{:ok, markets} = CCXT.Bybit.fetch_markets()
precision_mode = CCXT.Bybit.__ccxt_precision_mode__()

# Build precision map for all symbols
precision_map = MarketPrecision.from_markets(markets, precision_mode)
mp = precision_map["BTC/USDT"]

mp.price_increment   #=> 0.01
mp.price_precision   #=> 2
mp.amount_increment  #=> 0.001
mp.amount_precision  #=> 3
mp.price_min         #=> 0.05
mp.amount_min        #=> 0.001
mp.cost_min          #=> 10.0
```

### Precision Modes
Exchanges report precision differently. `MarketPrecision` normalizes across all modes:

| Mode | Value | `precision["price"]` means |
|------|-------|---------------------------|
| TICK_SIZE | 4 | Minimum price increment (e.g., `0.05`) |
| DECIMALS | 0 | Number of decimal places (e.g., `2`) |
| SIGNIFICANT_DIGITS | 1 | Not supported (returns error) |

Use `__ccxt_precision_mode__/0` to get the exchange's mode.

### TradingView Price Format
For chart libraries that need precision config:

```elixir
MarketPrecision.tradingview_price_format(mp)
#=> %{type: "price", precision: 2, minMove: 0.01}
```

### Raw Markets (Backward Compat)
If you previously accessed markets as raw maps (`market["symbol"]`), pass `normalize: false`:

```elixir
{:ok, raw_markets} = CCXT.Bybit.fetch_markets(normalize: false)
raw_markets |> hd() |> Map.get("symbol")
```

## 9) TradingView Charts (REST + WS)
Use REST for backfill and WebSocket for live updates.

- Backfill: `fetch_ohlcv` returns `{:ok, [%CCXT.Types.OHLCVBar{}]}`
- Live stream: `watch_ohlcv_subscription` + `CCXT.WS.Client` (public) or `*.WS.Adapter` (private/auth flows)

OHLCV data is automatically normalized to `%OHLCVBar{}` structs with named fields, sorted ascending by timestamp, and string values coerced to numbers. No exchange-specific normalizers needed.

```elixir
alias CCXT.Types.OHLCVBar

# REST backfill â€” already normalized
{:ok, bars} = CCXT.Bybit.fetch_ohlcv("BTC/USDT", "1m")
# => [%OHLCVBar{timestamp: 1704153600000, open: 42000.0, high: 42500.0, ...}, ...]

# Convert to TradingView format (timestamps in seconds, atom-keyed maps)
tv_bars = CCXT.OHLCV.to_tradingview(bars)
# => [%{time: 1704153600, open: 42000.0, high: 42500.0, ...}, ...]

# Convert to Lightweight Charts format (same as TradingView)
lw_bars = CCXT.OHLCV.to_lightweight_charts(bars)

# Custom adapter for SciChart or other libraries
sci_bars = CCXT.OHLCV.to_adapter(bars, fn bar ->
  {bar.timestamp, bar.open, bar.high, bar.low, bar.close}
end)

# Raw exchange payloads (skip normalization)
{:ok, raw} = CCXT.Bybit.fetch_ohlcv("BTC/USDT", "1m", normalize: false)
```

## 10) WebSocket Quickstart (Public Channels)
Use `CCXT.WS.Client` for simple public streams.

Bybit public OHLCV stream:

```elixir
spec = CCXT.Bybit.__ccxt_spec__()
{:ok, client} = CCXT.WS.Client.connect(spec, [:public, :spot], sandbox: true)

{:ok, sub} = CCXT.Bybit.WS.watch_ohlcv_subscription("BTC/USDT", "1m")
:ok = CCXT.WS.Client.subscribe(client, sub)

receive do
  {:websocket_message, raw} ->
    message =
      case raw do
        bin when is_binary(bin) -> Jason.decode!(bin)
        map when is_map(map) -> map
      end

    message
after
  10_000 ->
    :timeout
end

:ok = CCXT.WS.Client.unsubscribe(client, sub)
:ok = CCXT.WS.Client.close(client)
```

Deribit public OHLCV stream:

```elixir
spec = CCXT.Deribit.__ccxt_spec__()
{:ok, client} = CCXT.WS.Client.connect(spec, :public, sandbox: true)

{:ok, sub} = CCXT.Deribit.WS.watch_ohlcv_subscription("BTC-PERPETUAL", "1m")
:ok = CCXT.WS.Client.subscribe(client, sub)
```

## 11) WebSocket Advanced Operations
`CCXT.WS.Client.connect/3` supports:
- `:handler` custom message handler
- `:sandbox` testnet URL selection
- `:timeout` connection timeout
- `:debug` debug logs
- `:reconnect_on_error` pass-through reconnect behavior for underlying WS client
- `:restore_subscriptions` pass-through restore behavior for underlying WS client

Custom handler example:

```elixir
handler = fn msg ->
  IO.inspect(msg, label: "WS")
  :ok
end

spec = CCXT.Bybit.__ccxt_spec__()
{:ok, client} = CCXT.WS.Client.connect(spec, [:public, :spot], sandbox: true, handler: handler)
```

## 12) WebSocket Reconnection Model (Client vs Adapter)
Use this decision rule:

- `CCXT.WS.Client`: lightweight and stateless wrapper for simple/public streams.
- `CCXT.<Exchange>.WS.Adapter`: managed GenServer for reconnect + subscription restore + auth re-auth flows.

`CCXT.WS.Client` notes:
- It forwards `reconnect_on_error` to the underlying websocket client config.
- It does **not** track subscriptions itself for automatic recovery.
- If you reconnect manually, call `CCXT.WS.Client.restore_subscriptions/2` with your stored subscriptions.

Manual reconnect pattern with `CCXT.WS.Client`:

```elixir
spec = CCXT.Bybit.__ccxt_spec__()

{:ok, client} = CCXT.WS.Client.connect(spec, [:public, :spot], sandbox: true)
{:ok, sub} = CCXT.Bybit.WS.watch_ticker_subscription("BTC/USDT")
:ok = CCXT.WS.Client.subscribe(client, sub)

# keep your own list for manual restore
subscriptions = [sub]

# ... if disconnected ...
{:ok, new_client} = CCXT.WS.Client.connect(spec, [:public, :spot], sandbox: true)
:ok = CCXT.WS.Client.restore_subscriptions(new_client, subscriptions)
```

`CCXT.<Exchange>.WS.Adapter` notes:
- Tracks subscriptions and restores them after reconnect.
- Uses exponential backoff reconnect attempts internally.
- Tracks auth state (`:unauthenticated`, `:authenticating`, `:authenticated`, `:expired`).
- If previously authenticated, it re-authenticates after reconnect with retry (up to 3 attempts with exponential backoff).
- Query auth state with `Adapter.auth_state/1`.

For managed reconnection, prefer adapter processes for long-running or authenticated streams.

## 13) Private WebSocket Channels (Authenticated)
Use exchange adapters for authenticated WS flows (`*.WS.Adapter`) because they provide `authenticate/1`.

### Auth State Machine
The adapter tracks authentication through these states:

| State | Meaning |
|-------|---------|
| `:unauthenticated` | Not authenticated (initial state, or after disconnect) |
| `:authenticating` | Auth message sent, waiting for response |
| `:authenticated` | Successfully authenticated |
| `:expired` | Auth token expired (handler prepared, scheduling requires exchange-specific TTL data) |

Query auth state at any time:

```elixir
CCXT.Bybit.WS.Adapter.auth_state(adapter)
#=> :authenticated
```

### Pre-Auth Patterns (Listen Key / REST Token)
Some exchanges (e.g., Binance) require a REST call to obtain a listen key or token before WS auth. The adapter signals this:

```elixir
case CCXT.Binance.WS.Adapter.authenticate(adapter) do
  :ok ->
    # WS-native auth succeeded (e.g., HMAC signing)
    :ready

  {:error, {:pre_auth_required, metadata}} ->
    # Caller must complete auth via REST, then:
    # 1. Make the REST call described by metadata
    # 2. Call Adapter.mark_authenticated(adapter) when done
    :needs_rest_auth

  {:error, reason} ->
    {:auth_failed, reason}
end
```

### Bybit Private WS Flow

```elixir
creds = CCXT.Credentials.new!(
  api_key: System.fetch_env!("BYBIT_TESTNET_API_KEY"),
  secret: System.fetch_env!("BYBIT_TESTNET_API_SECRET"),
  sandbox: true
)

{:ok, adapter} =
  CCXT.Bybit.WS.Adapter.start_link(
    url_path: [:private, :spot, :unified],
    sandbox: true,
    credentials: creds
  )

:ok = CCXT.Bybit.WS.Adapter.authenticate(adapter)

spec = CCXT.Bybit.__ccxt_spec__()
{:ok, private_url} = CCXT.WS.Helpers.resolve_url(spec, [:private, :spot, :unified], sandbox: true)

{:ok, bal_sub} = CCXT.Bybit.WS.watch_balance_subscription(private_url)
{:ok, ord_sub} = CCXT.Bybit.WS.watch_orders_subscription(private_url, "BTC/USDT")

:ok = CCXT.Bybit.WS.Adapter.subscribe(adapter, bal_sub)
:ok = CCXT.Bybit.WS.Adapter.subscribe(adapter, ord_sub)
```

### Deribit Private WS Flow

```elixir
creds = CCXT.Credentials.new!(
  api_key: System.fetch_env!("DERIBIT_TESTNET_API_KEY"),
  secret: System.fetch_env!("DERIBIT_TESTNET_SECRET_KEY"),
  sandbox: true
)

{:ok, adapter} =
  CCXT.Deribit.WS.Adapter.start_link(
    url_path: :public,
    sandbox: true,
    credentials: creds
  )

:ok = CCXT.Deribit.WS.Adapter.authenticate(adapter)

{:ok, bal_sub} = CCXT.Deribit.WS.watch_balance_subscription()
{:ok, ord_sub} = CCXT.Deribit.WS.watch_orders_subscription("BTC-PERPETUAL")

:ok = CCXT.Deribit.WS.Adapter.subscribe(adapter, bal_sub)
:ok = CCXT.Deribit.WS.Adapter.subscribe(adapter, ord_sub)
```

## 14) WS Troubleshooting
If subscription/auth fails, check:
- exchange module and WS module (`CCXT.Bybit` vs `CCXT.Bybit.WS`)
- exact symbol format (`BTC/USDT` vs `BTCUSDT` vs `BTC-PERPETUAL`)
- `url_path` used in connect/start_link
- sandbox flag and testnet credential env vars
- first inbound WS message (raw JSON) and subscribe response
- whether channel needs auth (`auth_required: true`)

For Bybit private channels, URL routing matters (`watch_balance_subscription/2` and `watch_orders_subscription/3` require the resolved private URL).

Reconnection-specific checks:
- For `CCXT.WS.Client`, verify you are persisting subscriptions and calling `restore_subscriptions/2` after reconnect.
- For adapters, inspect `Adapter.get_state/1` for `auth_state`, `re_auth_attempts`, and active subscriptions.
- If reconnect stops, check for max reconnection attempts reached in logs.
- Use `Adapter.auth_state/1` to check current auth status (`:unauthenticated`, `:authenticating`, `:authenticated`, `:expired`).

Auth-specific checks:
- If `authenticate/1` returns `{:error, {:pre_auth_required, metadata}}`, the exchange needs a REST call first. Complete the REST auth flow, then call `Adapter.mark_authenticated/1`.
- If auth expires (state becomes `:expired`), the adapter has a handler prepared for re-auth. Expiry scheduling requires exchange-specific TTL data (not yet extracted).
- After disconnect, auth state resets to `:unauthenticated` and re-auth is attempted on reconnect.

## 15) Practical Support Rules for AI Assistants
When helping users, always ask for:
- exchange module (`CCXT.<Exchange>`)
- REST vs WebSocket path
- exact function call and params
- symbol format used
- full error tuple/message
- `sandbox: true` or production
- WS `url_path`, subscription map, and first received message

Then return a minimal runnable snippet tailored to that exact exchange and channel type.
