defmodule CCXT.Types.Schema.Position do
  @moduledoc """
  Auto-generated schema for `CCXT.Types.Position`.

  Source: priv/ccxt/ts/src/base/types.ts

  ## Fields

  - `symbol` - String.t()
  - `id` - String.t() | nil (optional)
  - `raw` - any()
  - `timestamp` - number() (optional)
  - `datetime` - String.t() (optional)
  - `contracts` - number() (optional)
  - `contract_size` - number() (optional)
  - `side` - String.t() | nil
  - `notional` - number() (optional)
  - `leverage` - number() (optional)
  - `unrealized_pnl` - number() (optional)
  - `realized_pnl` - number() (optional)
  - `collateral` - number() (optional)
  - `entry_price` - number() (optional)
  - `mark_price` - number() (optional)
  - `liquidation_price` - number() (optional)
  - `margin_mode` - String.t() | nil (optional)
  - `hedged` - boolean() (optional)
  - `maintenance_margin` - number() (optional)
  - `maintenance_margin_percentage` - number() (optional)
  - `initial_margin` - number() (optional)
  - `initial_margin_percentage` - number() (optional)
  - `margin_ratio` - number() (optional)
  - `last_update_timestamp` - number() (optional)
  - `last_price` - number() (optional)
  - `stop_loss_price` - number() (optional)
  - `take_profit_price` - number() (optional)
  - `percentage` - number() (optional)
  - `margin` - number() (optional)

  ## Usage

  This module is used by `CCXT.Types.Position`:

      defmodule CCXT.Types.Position do
        use CCXT.Types.Schema.Position
      end

  Do not edit this file manually - it will be overwritten by `mix ccxt.gen.types`.

  """

  @fields [
    %{name: :symbol, optional: false, source: "symbol", type: "String.t()"},
    %{name: :id, optional: true, source: "id", type: "String.t() | nil"},
    %{name: :raw, optional: false, source: "info", type: "any()"},
    %{name: :timestamp, optional: true, source: "timestamp", type: "number()"},
    %{name: :datetime, optional: true, source: "datetime", type: "String.t()"},
    %{name: :contracts, optional: true, source: "contracts", type: "number()"},
    %{name: :contract_size, optional: true, source: "contractSize", type: "number()"},
    %{name: :side, optional: false, source: "side", type: "String.t() | nil"},
    %{name: :notional, optional: true, source: "notional", type: "number()"},
    %{name: :leverage, optional: true, source: "leverage", type: "number()"},
    %{name: :unrealized_pnl, optional: true, source: "unrealizedPnl", type: "number()"},
    %{name: :realized_pnl, optional: true, source: "realizedPnl", type: "number()"},
    %{name: :collateral, optional: true, source: "collateral", type: "number()"},
    %{name: :entry_price, optional: true, source: "entryPrice", type: "number()"},
    %{name: :mark_price, optional: true, source: "markPrice", type: "number()"},
    %{name: :liquidation_price, optional: true, source: "liquidationPrice", type: "number()"},
    %{name: :margin_mode, optional: true, source: "marginMode", type: "String.t() | nil"},
    %{name: :hedged, optional: true, source: "hedged", type: "boolean()"},
    %{name: :maintenance_margin, optional: true, source: "maintenanceMargin", type: "number()"},
    %{
      name: :maintenance_margin_percentage,
      optional: true,
      source: "maintenanceMarginPercentage",
      type: "number()"
    },
    %{name: :initial_margin, optional: true, source: "initialMargin", type: "number()"},
    %{
      name: :initial_margin_percentage,
      optional: true,
      source: "initialMarginPercentage",
      type: "number()"
    },
    %{name: :margin_ratio, optional: true, source: "marginRatio", type: "number()"},
    %{
      name: :last_update_timestamp,
      optional: true,
      source: "lastUpdateTimestamp",
      type: "number()"
    },
    %{name: :last_price, optional: true, source: "lastPrice", type: "number()"},
    %{name: :stop_loss_price, optional: true, source: "stopLossPrice", type: "number()"},
    %{name: :take_profit_price, optional: true, source: "takeProfitPrice", type: "number()"},
    %{name: :percentage, optional: true, source: "percentage", type: "number()"},
    %{name: :margin, optional: true, source: "margin", type: "number()"}
  ]
  @type_spec_str """
  %__MODULE__{
    symbol: String.t(),
    id: String.t() | nil,
    raw: any(),
    timestamp: number() | nil,
    datetime: String.t() | nil,
    contracts: number() | nil,
    contract_size: number() | nil,
    side: String.t() | nil,
    notional: number() | nil,
    leverage: number() | nil,
    unrealized_pnl: number() | nil,
    realized_pnl: number() | nil,
    collateral: number() | nil,
    entry_price: number() | nil,
    mark_price: number() | nil,
    liquidation_price: number() | nil,
    margin_mode: String.t() | nil,
    hedged: boolean() | nil,
    maintenance_margin: number() | nil,
    maintenance_margin_percentage: number() | nil,
    initial_margin: number() | nil,
    initial_margin_percentage: number() | nil,
    margin_ratio: number() | nil,
    last_update_timestamp: number() | nil,
    last_price: number() | nil,
    stop_loss_price: number() | nil,
    take_profit_price: number() | nil,
    percentage: number() | nil,
    margin: number() | nil
  }
  """
  @type_spec Code.string_to_quoted!(@type_spec_str)

  defmacro __using__(opts) do
    fields = @fields
    type_spec = @type_spec
    struct_defaults = Keyword.get(opts, :struct_defaults, [])
    field_names = Enum.map(fields, & &1.name)

    struct_fields =
      Enum.map(field_names, fn name ->
        if Keyword.has_key?(struct_defaults, name) do
          {name, Keyword.fetch!(struct_defaults, name)}
        else
          name
        end
      end)

    quote do
      import CCXT.Types.Helpers, only: [get_value: 2, get_camel_value: 3]

      @fields unquote(Macro.escape(fields))
      @type_spec unquote(Macro.escape(type_spec))
      @type t :: unquote(type_spec)
      defstruct unquote(struct_fields)
      @spec from_map(map()) :: t()
      def from_map(map) when is_map(map) do
        %__MODULE__{
          symbol: get_value(map, :symbol),
          id: get_value(map, :id),
          raw: get_camel_value(map, :raw, :info),
          timestamp: get_value(map, :timestamp),
          datetime: get_value(map, :datetime),
          contracts: get_value(map, :contracts),
          contract_size: get_camel_value(map, :contract_size, :contractSize),
          side: get_value(map, :side),
          notional: get_value(map, :notional),
          leverage: get_value(map, :leverage),
          unrealized_pnl: get_camel_value(map, :unrealized_pnl, :unrealizedPnl),
          realized_pnl: get_camel_value(map, :realized_pnl, :realizedPnl),
          collateral: get_value(map, :collateral),
          entry_price: get_camel_value(map, :entry_price, :entryPrice),
          mark_price: get_camel_value(map, :mark_price, :markPrice),
          liquidation_price: get_camel_value(map, :liquidation_price, :liquidationPrice),
          margin_mode: get_camel_value(map, :margin_mode, :marginMode),
          hedged: get_value(map, :hedged),
          maintenance_margin: get_camel_value(map, :maintenance_margin, :maintenanceMargin),
          maintenance_margin_percentage:
            get_camel_value(map, :maintenance_margin_percentage, :maintenanceMarginPercentage),
          initial_margin: get_camel_value(map, :initial_margin, :initialMargin),
          initial_margin_percentage: get_camel_value(map, :initial_margin_percentage, :initialMarginPercentage),
          margin_ratio: get_camel_value(map, :margin_ratio, :marginRatio),
          last_update_timestamp: get_camel_value(map, :last_update_timestamp, :lastUpdateTimestamp),
          last_price: get_camel_value(map, :last_price, :lastPrice),
          stop_loss_price: get_camel_value(map, :stop_loss_price, :stopLossPrice),
          take_profit_price: get_camel_value(map, :take_profit_price, :takeProfitPrice),
          percentage: get_value(map, :percentage),
          margin: get_value(map, :margin)
        }
      end

      defoverridable from_map: 1
    end
  end
end
