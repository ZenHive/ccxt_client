defmodule CCXT.Types.Schema.Greeks do
  @moduledoc """
  Auto-generated schema for `CCXT.Types.Greeks`.

  Source: priv/ccxt/ts/src/base/types.ts

  ## Fields

  - `symbol` - String.t()
  - `timestamp` - number() (optional)
  - `datetime` - String.t() | nil (optional)
  - `delta` - number()
  - `gamma` - number()
  - `theta` - number()
  - `vega` - number()
  - `rho` - number()
  - `vanna` - number() (optional)
  - `volga` - number() (optional)
  - `charm` - number() (optional)
  - `bid_size` - number()
  - `ask_size` - number()
  - `bid_implied_volatility` - number()
  - `ask_implied_volatility` - number()
  - `mark_implied_volatility` - number()
  - `bid_price` - number()
  - `ask_price` - number()
  - `mark_price` - number()
  - `last_price` - number()
  - `underlying_price` - number()
  - `raw` - any()

  ## Usage

  This module is used by `CCXT.Types.Greeks`:

      defmodule CCXT.Types.Greeks do
        use CCXT.Types.Schema.Greeks
      end

  Do not edit this file manually - it will be overwritten by `mix ccxt.gen.types`.

  """

  Module.register_attribute(__MODULE__, :fields, persist: true)

  @fields [
    %{name: :symbol, optional: false, source: "symbol", type: "String.t()"},
    %{name: :timestamp, optional: true, source: "timestamp", type: "number()"},
    %{name: :datetime, optional: true, source: "datetime", type: "String.t() | nil"},
    %{name: :delta, optional: false, source: "delta", type: "number()"},
    %{name: :gamma, optional: false, source: "gamma", type: "number()"},
    %{name: :theta, optional: false, source: "theta", type: "number()"},
    %{name: :vega, optional: false, source: "vega", type: "number()"},
    %{name: :rho, optional: false, source: "rho", type: "number()"},
    %{name: :vanna, optional: true, source: "vanna", type: "number()"},
    %{name: :volga, optional: true, source: "volga", type: "number()"},
    %{name: :charm, optional: true, source: "charm", type: "number()"},
    %{name: :bid_size, optional: false, source: "bidSize", type: "number()"},
    %{name: :ask_size, optional: false, source: "askSize", type: "number()"},
    %{
      name: :bid_implied_volatility,
      optional: false,
      source: "bidImpliedVolatility",
      type: "number()"
    },
    %{
      name: :ask_implied_volatility,
      optional: false,
      source: "askImpliedVolatility",
      type: "number()"
    },
    %{
      name: :mark_implied_volatility,
      optional: false,
      source: "markImpliedVolatility",
      type: "number()"
    },
    %{name: :bid_price, optional: false, source: "bidPrice", type: "number()"},
    %{name: :ask_price, optional: false, source: "askPrice", type: "number()"},
    %{name: :mark_price, optional: false, source: "markPrice", type: "number()"},
    %{name: :last_price, optional: false, source: "lastPrice", type: "number()"},
    %{name: :underlying_price, optional: false, source: "underlyingPrice", type: "number()"},
    %{name: :raw, optional: false, source: "info", type: "any()"}
  ]
  @type_spec_str """
  %__MODULE__{
    symbol: String.t(),
    timestamp: number() | nil,
    datetime: String.t() | nil,
    delta: number(),
    gamma: number(),
    theta: number(),
    vega: number(),
    rho: number(),
    vanna: number() | nil,
    volga: number() | nil,
    charm: number() | nil,
    bid_size: number(),
    ask_size: number(),
    bid_implied_volatility: number(),
    ask_implied_volatility: number(),
    mark_implied_volatility: number(),
    bid_price: number(),
    ask_price: number(),
    mark_price: number(),
    last_price: number(),
    underlying_price: number(),
    raw: any()
  }
  """
  @type_spec Code.string_to_quoted!(@type_spec_str)

  defmacro __using__(opts) do
    fields = @fields
    type_spec = @type_spec
    struct_defaults = Keyword.get(opts, :struct_defaults, [])
    field_names = Enum.map(fields, & &1.name)

    struct_fields =
      Enum.map(field_names, fn name ->
        if Keyword.has_key?(struct_defaults, name) do
          {name, Keyword.fetch!(struct_defaults, name)}
        else
          name
        end
      end)

    quote do
      import CCXT.Types.Helpers, only: [get_value: 2, get_camel_value: 3]

      @fields unquote(Macro.escape(fields))
      @type_spec unquote(Macro.escape(type_spec))
      @type t :: unquote(type_spec)
      defstruct unquote(struct_fields)
      @spec from_map(map()) :: t()
      def from_map(map) when is_map(map) do
        %__MODULE__{
          symbol: get_value(map, :symbol),
          timestamp: get_value(map, :timestamp),
          datetime: get_value(map, :datetime),
          delta: get_value(map, :delta),
          gamma: get_value(map, :gamma),
          theta: get_value(map, :theta),
          vega: get_value(map, :vega),
          rho: get_value(map, :rho),
          vanna: get_value(map, :vanna),
          volga: get_value(map, :volga),
          charm: get_value(map, :charm),
          bid_size: get_camel_value(map, :bid_size, :bidSize),
          ask_size: get_camel_value(map, :ask_size, :askSize),
          bid_implied_volatility: get_camel_value(map, :bid_implied_volatility, :bidImpliedVolatility),
          ask_implied_volatility: get_camel_value(map, :ask_implied_volatility, :askImpliedVolatility),
          mark_implied_volatility: get_camel_value(map, :mark_implied_volatility, :markImpliedVolatility),
          bid_price: get_camel_value(map, :bid_price, :bidPrice),
          ask_price: get_camel_value(map, :ask_price, :askPrice),
          mark_price: get_camel_value(map, :mark_price, :markPrice),
          last_price: get_camel_value(map, :last_price, :lastPrice),
          underlying_price: get_camel_value(map, :underlying_price, :underlyingPrice),
          raw: get_camel_value(map, :raw, :info)
        }
      end

      defoverridable from_map: 1
    end
  end
end
